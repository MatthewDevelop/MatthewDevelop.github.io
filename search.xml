<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Google搜索技巧]]></title>
    <url>%2F2019%2F03%2F21%2FGoogle%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[平时使用百度或者Google的搜索引擎时，我们经常在搜索栏中输入“Android定位功能如何实现？”，“电脑蓝屏怎么办？”等类似带有一种语气的搜索关键字。搜索引擎其实终究是机器，他并不能很好的理解你的语义，从而给你最匹配的搜索结果。如果我们把关键字稍微精简一下变成“Android 定位功能 实现”和“蓝屏 解决方案”（关键字之间空格分开），去除一些搜索引擎无法理解的语气词，搜索引擎就可以根据你给出的关键字，更好的展示搜索结果，从而提高搜索效率。 本文记录一些搜索技巧，帮助大家提高搜索效率。（以Google搜索引擎为例，程序猿还是比较喜欢Google的） 使用 “” 进行完全匹配 场景：使用关键字 Android网络定位 进行搜索时，搜索结果是根据“Android”、“网络”、“定位”等关键字进行无序的匹配获取搜索结果。 解决方案： 使用&quot;&quot;通配符，指定完全匹配关键字 使用&quot;Android网络定位&quot;，将会展示关键字完全匹配的搜索结果。 使用 - 排除关键字 场景：使用关键字 Android网络定位 进行搜索时，不想出现GPS关键字。 解决方案： 使用 - 进行排除关键字 在搜索框中输入Android网络定位 -GPS，就会展示去除GPS关键字之后的搜索结果 使用 * 进行模糊匹配 场景：搜索一本书，但是书名记不清，只记得几个关键字 Android 艺术 解决方案： 使用 * 通配符进行模糊搜索 输入关键字 Android*艺术 就可以获取模糊匹配的结果。 使用 site:[domain.com] 指定网站 场景：想搜索写作技巧，但只想看知乎大神给出的写作技巧 解决方案： 关键字后添加 site:[domain.com] 指定搜索站点 搜索引擎中输入关键字 写作技巧 site:zhihu.com ，将会只展示知乎上的结果 场景：想搜索写作技巧，排除知乎上的搜索结果 解决方案： 关键字后添加 -site:domain.com 指定搜索站点 搜索引擎中输入关键字 写作技巧 -site:zhihu.com ，将会展示去除知乎后的搜索结果 使用 filetype:[filetype]指定文件类型 场景：想要搜索 第一行代码 的pdf文件 解决方案： 使用 filetype:[filetype] 限定文件类型 搜索引擎中输入关键字 第一行代码 filetype:pdf，将会展示有`第一行代码 关键字的pdf文件 Tips: Google支持的文件类型有限，例如epub类型的文件就不支持，可能需要在Search Console Help上查一下支持哪些文件。]]></content>
      <tags>
        <tag>Google</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试凉凉经]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%9D%A2%E8%AF%95%E5%87%89%E5%87%89%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[本篇还没整理完，完全是为了方便查看 不出去试试就不知道自己有多弱~ Handler的机制为什么要用HandlerAndroid规定只能再主线程(UI线程)中更新UI，如果再子线程中操作UI会引起程序崩溃，那么这时候就需要用到Handler,来发送消息通知主线程更新UI。 创建Handler 在主线程中可以直接创建Handler 子线程中必选先调用Looper.prepare()才可以创建Handler，创建Handler后还需要调用Looper.loop()来启动消息循环。 子线程中创建Handler时传入UI线程的Looper就不必调用Looper.prapare()和Looper.loop() 1234567891011new Thread(new Runnable() &#123; public void run() &#123; Handler handler = new Handler(Looper.getMainLooper())&#123; // 区别在这！！！！ @Override public void handleMessage(Message msg) &#123; Toast.makeText(getApplicationContext()"handler msg", Toast.LENGTH_LONG).show(); &#125; &#125;; handler.sendEmptyMessage(1); &#125;; &#125;).start(); 主线程在创建的时候会默认创建Looper和Message Queue Handler工作原理（异步消息处理机制）异步消息处理机制中的几个要素: Message Handler接受和处理的对象 Message Queue 存储消息对象的队列 Looper 循环读取Message Queue中的消息，并把读取到的消息分发到对于的Handler进行处理 Handler 发送和处理消息 流程： 步骤 描述 备注 异步通信准备 在主线程中创建：- 处理器：Looper- 消息队列：Message Queue- Handler -Looper,Message Queue均属于主线程-创建Message Queue后Looper自动进入循环-此时Handler自动绑定了主线程的Looper和Message Queue 消息入队 工作线程通过Handler发送Message到消息列队中 消息内容就是工作线程对UI的操作 消息循环 - 消息出队：Looper循环取出消息列队中的消息- 消息分发：Looper将取出的消息发送到创建该消息的处理者 Looper在循环处理过程中，若消息列队为空，就会阻塞，直到新的消息入队 消息处理 - 处理者Handler接受处理器Looper发送过来的消息- 处理者Handler根据消息操作UI Handler除了处理消息还负责发送消息 如下图： 子线程中更新UI的方式 Handler.post(Runnable) Handler.sendMessage(Message) runOnUiThread(Runnable) View.post(Runnable) 无论上面的那种方法，实质上都是通过Handler将消息发送到主线程中更新UI 注意线程（Thread）、循环器（Looper）、处理者（Handler）之间的对应关系如下： 个线程（Thread）只能绑定 1个循环器（Looper），但可以有多个处理者（Handler） 1个循环器（Looper） 可绑定多个处理者（Handler） 1个处理者（Handler） 只能绑定1个1个循环器（Looper） 疑问如果在子线程中创建Handler,并重写HandleMessage方法，处理UI会怎么样？ 会产生异常，Handler的HandlerMessage方法是运行在Handler所绑定Looper所在的线程中，所以还是属于在子线程中处理UI 参考Android 异步通信：图文详解Handler机制工作原理 Android的事件传递事件分发顺序Activity-&gt;window-&gt;decorView-&gt;ViewGroup-&gt;View事件处理顺序View-&gt;ViewGroup-&gt;decorView-&gt;Window-&gt;ActivityViewGroup的事件传递方法dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent()View的事件传递方法dispatchTouchEvent()、onTouchEvent() Android UI适配 https://www.jianshu.com/p/a4b8e4c5d9b0?tdsourcetag=s_pcqq_aiomsg 使用dp作为布局的长宽单位自适应布局Weight比例布局 宽高限定符 最小宽限定符 View的绘制流程用面向对象的思维方式来思考，就会觉的View的绘制机制是很合理，很科学的。我们要在一张纸上画一幅画，首先要测量一下这幅画有多大吧，然后确定在这张纸的哪个地方画会显得比较美观，最后才是用画笔工具将画绘制在纸上。 在Android中也是一样的。View的绘制流程主要是指measure，layout，draw这三步，即测量，布局，绘制。首先是要测量View的宽高，然后布局确定在父容器中的位置坐标，最后才是绘制显示出来。 View的绘制流程从ViewRootImpl的performTraversals方法开始，在performTraversals方法中会调用performMeasure、performLayout、performDraw三个方法来遍历完成整棵视图树的绘制。 1234567891011int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);...// 测量performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);...// 布局performLayout(lp, mWidth, mHeight);...// 绘制performDraw(); MeasureMeasureSpec是什么？ MeasureSpec从字面上是测量说明书的意思，是View的测量过程中很关键的要素。 MeasureSpec 表示的是一个 32 位的整数值，它的高 2 位表示测量模式 SpecMode，低 30 位表示某种测量模式下的规格大小 SpecSize。 SpecMode有三种 UNSPECIFIED不指定测量模式，父视图没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少使用到。 EXACTLY精确测量模式，当该视图的 layout_width 或者 layout_height 指定为具体数值或者 match_parent 时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值。 AT_MOST最大值模式，当前视图的 layout_width 或者 layout_height 指定为 wrap_content 时生效，父容器指定了一个可用大小specSize，此时子视图的尺寸可以是不超过父容器指定最大尺寸的任何尺寸。 有什么作用？ 系统是通过View的MeasureSpec来确定View的测量宽高。 MeasureSpec怎么来的？ 对于普通的View来说，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams共同确定。对于顶级View（DecorView），其MeasureSpec由窗口的尺寸和其自身的LayoutParams共同确定。 LayoutDrawAndroid进程间通信定义多进程Android中使用多进程的方法只有一个（用NDK的fork来做除外），就是在AndroidManifest.xml中声明组件时，用android:process属性来指定。 不知定process属性，则默认运行在主进程中，主进程名字为包名。 android:process = package:remote，将运行在package:remote进程中，属于全局进程，其他具有相同shareUID与签名的APP可以跑在这个进程中。 android:process = :remote ，将运行在默认包名:remote进程中，而且是APP的私有进程，不允许其他APP的组件来访问。 多进程引发的问题静态成员和单例失效：每个进程保持各自的静态成员和单例，相互独立。 线程同步机制失效：每个进程有自己的线程锁。 SharedPreferences可靠性下降：不支持并发写，会出现脏数据。 Application多次创建：不同进程跑在不同虚拟机，每个虚拟机启动会创建自己的Application，自定义Application时生命周期会混乱。 综上，不同进程拥有各自独立的虚拟机，Application，内存空间，由此引发一系列问题。 进程间通信 Bundle/Intent传递数据： 可传递基本类型，String，实现了Serializable或Parcellable接口的数据结构。Serializable是Java的序列化方法，Parcellable是Android的序列化方法，前者代码量少（仅一句），但I/O开销较大，一般用于输出到磁盘或网卡；后者实现代码多，效率高，一般用户内存间序列化和反序列化传输。 文件共享： 对同一个文件先后写读，从而实现传输，Linux机制下，可以对文件并发写，所以要注意同步。顺便一提，Windows下不支持并发读或写。 Messenger： Messenger是基于AIDL实现的，服务端（被动方）提供一个Service来处理客户端（主动方）连接，维护一个Handler来创建Messenger，在onBind时返回Messenger的binder。 双方用Messenger来发送数据，用Handler来处理数据。Messenger处理数据依靠Handler，所以是串行的，也就是说，Handler接到多个message时，就要排队依次处理。 AIDL： AIDL通过定义服务端暴露的接口，以提供给客户端来调用，AIDL使服务器可以并行处理，而Messenger封装了AIDL之后只能串行运行，所以Messenger一般用作消息传递。 通过编写aidl文件来设计想要暴露的接口，编译后会自动生成响应的java文件，服务器将接口的具体实现写在Stub中，用iBinder对象传递给客户端，客户端bindService的时候，用asInterface的形式将iBinder还原成接口，再调用其中的方法。 ContentProvider： 系统四大组件之一，底层也是Binder实现，主要用来为其他APP提供数据，可以说天生就是为进程通信而生的。自己实现一个ContentProvider需要实现6个方法，其中onCreate是主线程中回调的，其他方法是运行在Binder之中的。自定义的ContentProvider注册时要提供authorities属性，应用需要访问的时候将属性包装成Uri.parse(“content://authorities”)。还可以设置permission，readPermission，writePermission来设置权限。 ContentProvider有query，delete，insert等方法，看起来貌似是一个数据库管理类，但其实可以用文件，内存数据等等一切来充当数据源，query返回的是一个Cursor，可以自定义继承AbstractCursor的类来实现。 Socket： 学过计算机网络的对Socket不陌生，所以不需要详细讲述。只需要注意，Android不允许在主线程中请求网络，而且请求网络必须要注意声明相应的permission。然后，在服务器中定义ServerSocket来监听端口，客户端使用Socket来请求端口，连通后就可以进行通信。 js和Android交互 https://blog.csdn.net/carson_ho/article/details/64904691 js2android addJavascriptInterface() 有漏洞 webviewClient的shouldOverrideUrlLoading()拦截url WebChromeClient的onAlert()、onJsconfirm（）、onJsPrompt（）拦截对话框消息 android2Js webview.loadurl() webview.evaluateJavascript()仅限于4.4以上 android进程保活黑白灰 黑：不同app进程互相唤醒 白：启动前台服务（状态栏会有一条信息提示app正在运行） 灰：利用系统漏洞开启前台服务（状态栏无提示）（apiapi&gt;18 同时启动两个id相同的前台service，再将后启动的关闭） 算法 选择123456789101112public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min])) min = j; &#125; exch(a, i, min); assert isSorted(a, 0, i); &#125; assert isSorted(a);&#125;]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler引起的内存泄漏的原因和最佳解决方案]]></title>
    <url>%2F2019%2F03%2F09%2FHandler%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E6%9C%80%E4%BD%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Handler导致的内存泄漏是Android开发过程中非常常见的一种内存泄漏，本文讲解Handler导致的App内存泄漏的原因和最佳解决方案 Handler导致内存泄漏方式 Handler允许我们发送延时消息，如果在延时的过程中关闭了该Activity，那么该Activity就会泄漏。 原因 首先Message会持有Handler，其次由于Java语言特性，非静态内部类默认持有外部类的引用，所以Activity会被Handler持有，这样最终就导致了Activity的泄漏。 最佳解决方案 将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息。 示例代码如下：12345678910111213141516private static class SafeHandler extends Handler &#123; private WeakReference&lt;HandlerActivity&gt; ref; public SafeHandler(HandlerActivity activity) &#123; this.ref = new WeakReference(activity); &#125; @Override public void handleMessage(final Message msg) &#123; HandlerActivity activity = ref.get(); if (activity != null) &#123; activity.handleMessage(msg); &#125; &#125;&#125; 再在 Activity.onDestroy() 方法前移除所有消息：12345@Overrideprotected void onDestroy() &#123; safeHandler.removeCallbacksAndMessages(null); super.onDestroy();&#125; 这样双重保障，就可以完全避免内存泄漏。 注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。 参考：Handler都没搞懂，拿什么去跳槽啊？！]]></content>
      <tags>
        <tag>Handler</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub静态博客绑定自定义域名]]></title>
    <url>%2F2019%2F03%2F08%2FGitHub%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[本篇记录给GitHub静态博客绑定自定义域名的过程 同事今天和我说他昨天买了个域名，阿里云上入手的，10年只需199，域名是.tech结尾的。哎呀！这个域名很适合做技术博客的域名，GitHub静态博客的域名刚好不是很好看，给它弄个简单明了的自定义域名岂不刚好！手剁了！ 准备 搭建GitHub静态博客 购买自定义域名 搭建GitHub静态博客我之前搭建博客的时候，是看着同事的搭建教程来搭建的，搭建完成后也没有写一篇博文来记录一下，以后补上，这里就当大家都已经有自己的静态博客了吧~ 这里贴一个可以参考的博客: 最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 买域名这一步就是简单直接，选中自己想要的域名，直接下单付款就完事。 购买地址： 阿里云域名购买 域名绑定 域名绑定是需要双向绑定的，阿里云控制台域名解析配置需要绑定到博客，Github博客同样需要绑定到自定义域名，这样无论输入原来的博客地址还是输入自定义域名，都可以解析到自定已的域名！ 阿里云控制台配置买好了域名后，就可以登陆阿里云的控制台了，进入域名控制台，应该可以看到下面这个界面： 域名刚买好还是不能使用的，刚买好时你看见上图中的域名状态应该显示的是 需实名 的状态，哈哈，在天朝就是啥都需要实名。 点击进入实名界面，填写个人信息，然后上传身份证正面照，然后等着就好！大约半个小时吧，就会收到短信提示实名验证通过，那么就可以开始进行下一步了，把域名关联到GitHub静态博客了。 点击上图中解析按钮，就可以进入域名解析配置的界面了，如下图： 在网上查询了很多的资料讲解如何添加域名解析配置，很多人提到，要通过 ping [username].github.io 来获取静态博客的IP地址，再添加到域名解析配置中，那种方式应该过期了吧，我尝试了，但是没有成功。 下面是亲测可行的配置方式,只需添加两条解析记录： 点击添加记录，记录类型选中 CNAME ,两条解析记录的主机记录分别填写 @ 和 A，记录值均为 [your github username].github.io ，保存即可！ Tips： @ 表示直接解析主域名A 代表前缀为 www所以你访问 www.matthewdev.tech 和 matthewdev.tech 均可以解析到我的博客地址。 至此，阿里云域名控制台配置完成。 Github博客配置需要在博客里添加一个CNAME文件，如果直接在Github的静态博客仓库里添加文件的话，这样每次发布博客的时候，CNAME 文件会被覆盖删除掉。 解决方案是，在本地博客仓库的Source目录下新建CNAME文件，CNAME 文件的内容是你的自定义域名，不需要前缀的，我这里是matthewdev.tech,然后将内容发布到远程仓库。 至此，博客端也配置完成！ 现在在浏览器输入自定义的域名，应该就可以访问到你的博客了！ 总结 坑估计就在配置域名解析的地方吧，网上的很多博客都是很久之前写的，那个时候应该是要配置IP的，现在不需要了，直接添加两条CNAME的解析记录就好。 好了，笔记写完了！]]></content>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求数据加密以及加签校验]]></title>
    <url>%2F2019%2F03%2F08%2FHTTP%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E5%8A%A0%E7%AD%BE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[这段时间]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>网络请求</tag>
        <tag>AES</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试笔记]]></title>
    <url>%2F2019%2F03%2F05%2FAndroid%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录Android面试中可能会遇到的面试题目和答案 线程Java中线程的创建方式Java中有三种创建线程的方式，或者说四种: 继承Thread类实现多线程 实现Runnable接口 实现Callable接口 通过线程池 线程池的工作原理线程池可以减少创建和销毁线程的次数，从而减少系统资源的消耗，当一个任务提交到线程池时： 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常 Handler 这篇博客讲解Handler非常详细：Handler都没搞懂，拿什么去跳槽啊？！ Handler工作原理Handler，Message，looper 和 MessageQueue 构成了安卓的消息机制，handler创建后可以通过 sendMessage 将消息加入消息队列，然后 looper不断的将消息从 MessageQueue 中取出来，回调到 Hander 的 handleMessage方法，从而实现线程的通信。 从两种情况来说，第一在UI线程创建Handler,此时我们不需要手动开启looper，因为在应用启动时，在ActivityThread的main方法中就创建了一个当前主线程的looper，并开启了消息队列，消息队列是一个无限循环，为什么无限循环不会ANR?因为可以说，应用的整个生命周期就是运行在这个消息循环中的，安卓是由事件驱动的，Looper.loop不断的接收处理事件，每一个点击触摸或者Activity每一个生命周期都是在Looper.loop的控制之下的，looper.loop一旦结束，应用程序的生命周期也就结束了。我们可以想想什么情况下会发生ANR，第一，事件没有得到处理，第二，事件正在处理，但是没有及时完成，而对事件进行处理的就是looper，所以只能说事件的处理如果阻塞会导致ANR，而不能说looper的无限循环会ANR。 另一种情况就是在子线程创建Handler,此时由于这个线程中没有默认开启的消息队列，所以我们需要手动调用looper.prepare(),并通过looper.loop开启消息 主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。 内存内存泄漏的场景和解决方案 非静态内部类的静态实例 非静态内部类会持有外部类的引用，如果非静态内部类的实例是静态的，就会长期的维持着外部类的引用，组织被系统回收。 解决办法是： 使用静态内部类 多线程相关的匿名内部类和非静态内部类 匿名内部类同样会持有外部类的引用，如果在线程中执行耗时操作就有可能发生内存泄漏，导致外部类无法被回收，直到耗时任务结束。 解决办法是 在页面退出时结束线程中的任务 Handler内存泄漏 Handler导致的内存泄漏也可以被归纳为非静态内部类导致的，Handler内部message是被存储在MessageQueue中的，有些message不能马上被处理，存在的时间会很长，导致handler无法被回收，如果handler是非静态的，就会导致它的外部类无法被回收. 解决办法是: 使用静态handler，外部类引用使用弱引用处理 在退出页面时移除消息队列中的消息 Context导致内存泄漏 单例模式是最常见的发生此泄漏的场景，比如传入一个Activity的Context被静态类引用，导致无法回收。 解决办法是: 根据场景确定使用Activity的Context还是Application的Context,因为二者生命周期不同，对于不必须使用Activity的Context的场景（Dialog）,一律采用Application的Context。 静态View导致泄漏 使用静态View可以避免每次启动Activity都去读取并渲染View，但是静态View会持有Activity的引用，导致无法回收。（View一旦被加载到界面中将会持有一个Context对象的引用，在这个例子中，这个context对象是我们的Activity，声明一个静态变量引用这个View，也就引用了activity） 解决办法是 在Activity销毁的时候将静态View设置为null WebView导致的内存泄漏 WebView只要使用一次，内存就不会被释放，所以WebView都存在内存泄漏的问题。 通常的解决办法是 为WebView单开一个进程，使用AIDL进行通信，根据业务需求在合适的时机释放掉 资源对象未关闭导致 如Cursor，File等，内部往往都使用了缓冲，会造成内存泄漏，一定要确保关闭它并将引用置为null。 集合中的对象未清理 集合用于保存对象，如果集合越来越大，不进行合理的清理，尤其是如果集合是静态的。 Bitmap导致内存泄漏 Bitmap是比较占内存的，所以一定要在不使用的时候及时进行清理，避免静态变量持有大的Bitmap对象。 监听器未关闭很多需要register和unregister的系统服务要在合适的时候进行unregister,手动添加的listener也需要及时移除。 OOM什么是OOM?程序申请内存过大，虚拟机无法满足我们，然后自杀了。这个现象通常出现在大图片的APP开发，或者需要用到很多图片的时候。通俗来讲就是我们的APP需要申请一块内存来存放图片的时候，系统认为我们的程序需要的内存过大，及时系统有充分的内存，比如1G，但是系统也不会分配给我们的APP，故而抛出OOM异常，程序没有捕捉异常，故而弹窗崩溃了. 为什么有OOM?因为Android系统的APP每个进程或者虚拟机有最大内存限制，一旦超过这个限制系统就会抛出OOM错误。跟手机剩余内存是否充足没有多少关系。 如何避免OOM? 使用更加轻量的数据结构：如使用ArrayMap/SparseArray替代HashMap,HashMap更耗内存，因为它需要额外的实例对象来记录Mapping操作，SparseArray更加高效，因为它避免了Key Value的自动装箱，和装箱后的解箱操作。 减少枚举的使用，可以用静态常量或者注解@IntDef替代 Bitmap优化: 尺寸压缩：通过InSampleSize设置合适的缩放 颜色质量：设置合适的format，ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异 inBitmap:使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小，但复用存在一些限制，具体体现在：在Android 4.4之前只能重用相同大小的Bitmap的内存，而Android 4.4及以后版本则只要后来的Bitmap比之前的小即可。使用inBitmap参数前，每创建一个Bitmap对象都会分配一块内存供其使用，而使用了inBitmap参数后，多个Bitmap可以复用一块内存，这样可以提高性能 简单通过SoftReference引用方式管理图片资源建一个SoftReference的hashmap，使用图片时，先检查这个hashmap是否有softreference，softreference的图片是否为空，如果为空将图片加载到softreference并加入haspmap。 参考：什么是OOM？如何解决OOM问题! 使用更小的图片 StringBuilder替代String: 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。 避免在类似onDraw这样的方法中创建对象，因为它会迅速占用大量内存，引起频繁的GC甚至内存抖动。 减少内存泄漏也是一种避免OOM的方法 Activity启动模式 Standard 模式: Activity 可以有多个实例，每次启动 Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例。 SingleTop模式: 当一个singleTop模式的Activity已经位于任务栈的栈顶，再去启动它时，不会再创建新的实例,如果不位于栈顶，就会创建新的实例。 SingleTask模式: 如果Activity已经位于栈顶，系统不会创建新的Activity实例，和singleTop模式一样。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶，并把它上面的activity出栈。 SingleInstance模式: singleInstance 模式也是单例的，但和singleTask不同，singleTask 只是任务栈内单例，系统里是可以有多个singleTask Activity实例的，而 singleInstance Activity 在整个系统里只有一个实例，启动一singleInstanceActivity 时，系统会创建一个新的任务栈，并且这个任务栈只有他一个Activity。 生命周期 Activity生命周期方法的执行顺序为：onCreate-&gt; onStart-&gt; onResume-&gt; onPause-&gt; onStop-&gt; onDestroy 两个Activity跳转时生命周期方法的执行顺序为： 启动A onCreate - onStart - onResume 在A中启动B ActivityA onPause ActivityB onCreate ActivityB onStart ActivityB onResume ActivityA onStop 从B中返回A（按物理硬件返回键）ActivityB onPauseActivityA onRestartActivityA onStartActivityA onResumeActivityB onStopActivityB onDestroy 继续返回ActivityA onPauseActivityA onStopActivityA onDestroy onRestart()的调用场景 按下home键之后，然后切换回来，会调用onRestart()。 从本Activity跳转到另一个Activity之后，按back键返回原来Activity，会调用onRestart()。 从本Activity切换到其他的应用，然后再从其他应用切换回来，会调用onRestart()。 Activity 的横竖屏的切换的生命周期，如何保存数据ViewSurfaceView，它是什么？他的继承方式是什么？他与View的区别(从源码角度，如加载，绘制等)。SurfaceView中采用了双缓冲机制，保证了UI界面的流畅性，同时 SurfaceView 不在主线程中绘制，而是另开辟一个线程去绘制，所以它不妨碍UI线程； SurfaceView 继承于View，他和View主要有以下三点区别： View底层没有双缓冲机制，SurfaceView有 view主要适用于主动更新，而SurfaceView适用与被动的更新，如频繁的刷新 view会在主线程中去更新UI，而SurfaceView则在子线程中刷新 SurfaceView的内容不在应用窗口上，所以不能使用变换（平移、缩放、旋转等）。也难以放在ListView或者ScrollView中，不能使用UI控件的一些特性比如View.setAlpha()。 View：显示视图，内置画布，提供图形绘制函数、触屏事件、按键事件函数等；必须在UI主线程内更新画面，速度较慢。 SurfaceView：基于view视图进行拓展的视图类，更适合2D游戏的开发；是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快，Camera预览界面使用SurfaceView。 GLSurfaceView：基于SurfaceView视图再次进行拓展的视图类，专用于3D游戏开发的视图；是SurfaceView的子类，openGL专用。 设计模式和使用场景 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。使用场景比如最常见的AlertDialog,拿我们开发过程中举例，比如Camera开发过程中，可能需要设置一个初始化的相机配置，设置摄像头方向，闪光灯开闭，成像质量等等，这种场景下就可以使用建造者模式。 装饰者模式：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。装饰者模式可以在不改变原有类结构的情况下曾强类的功能，比如Java中的BufferedInputStream 包装FileInputStream，举个开发中的例子，比如在我们现有网络框架上需要增加新的功能，那么再包装一层即可，装饰者模式解决了继承存在的一些问题，比如多层继承代码的臃肿，使代码逻辑更清晰。 观察者模式： 代理模式： 门面模式： 单例模式： 生产者消费者模式： 进程如何实现进程保活 Service 设置成 START_STICKY kill 后会被重启(等待5秒左右)，重传Intent，保持与重启前一样 通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill 双进程Service： 让2个进程互相保护对方，其中一个Service被清理后，另外没被清理的进程可以立即重启进程 用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响(Android5.0以上的版本不可行）联系厂商，加入白名单 锁屏状态下，开启一个一像素Activity 应用冷启动与热启动是什么，区别，如何优化，使用场景等 冷启动：当应用启动时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用， 这个启动方式就叫做冷启动（后台不存在该应用进程）。冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。 热启动：当应用已经被打开， 但是被按下返回键、Home键等按键时回到桌面或者是其他程序的时候，再重新打开该app时， 这个方式叫做热启动（后台已经存在该应用进程）。热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化Application 冷启动的流程当点击app的启动图标时，安卓系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类、创建MainActivity类、加载主题样式Theme中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性、再inflate布局、当onCreate/onStart/onResume方法都走完了后最后才进行contentView的measure/layout/draw显示在界面上 冷启动的生命周期简要流程：Application构造方法 –&gt; attachBaseContext()–&gt;onCreate –&gt;Activity构造方法 –&gt; onCreate() –&gt; 配置主体中的背景等操作 –&gt;onStart() –&gt; onResume() –&gt; 测量、布局、绘制显示 冷启动的优化：主要是视觉上的优化，解决白屏问题，提高用户体验，所以通过上面冷启动的过程。能做的优化如下： 减少 onCreate()方法的工作量 不要让 Application 参与业务的操作 不要在 Application 进行耗时操作 不要以静态变量的方式在 Application 保存数据 减少布局的复杂度和层级 减少主线程耗时 为什么冷启动会有白屏黑屏问题？原因在于加载主题样式Theme中的windowBackground等属性设置给MainActivity发生在inflate布局当onCreate/onStart/onResume方法之前，而windowBackground背景被设置成了白色或者黑色，所以我们进入app的第一个界面的时候会造成先白屏或黑屏一下再进入界面。解决思路如下： 给他设置 windowBackground 背景跟启动页的背景相同，如果你的启动页是张图片那么可以直接给 windowBackground 这个属性设置该图片那么就不会有一闪的效果了 1234&lt;style name="Splash_Theme" parent="@android:style/Theme.NoTitleBar"&gt; &lt;item name="android:windowBackground"&gt;@drawable/splash_bg&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 采用世面的处理方法，设置背景是透明的，给人一种延迟启动的感觉。,将背景颜色设置为透明色,这样当用户点击桌面APP图片的时候，并不会”立即”进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground 的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦） 1234&lt;style name="Splash_Theme" parent="@android:style/Theme.NoTitleBar"&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 以上两种方法是在视觉上显得更快，但其实只是一种表象，让应用启动的更快，有一种思路，将 Application 中的不必要的初始化动作实现懒加载，比如，在SpashActivity 显示后再发送消息到 Application，去初始化，这样可以将初始化的动作放在后边，缩短应用启动到用户看到界面的时间 ANR 在Andorid上，系统会通过Activity Manager和Window Manager服务来监控应用的响应情况，如果应用响应超出限定时间了，为了避免对用户的体验造成困扰，系统就会弹出ANR提示供用户选择是否继续等待应用响应。 ANR的几种类型 主要类型：KeyDispatchTimeout(5 seconds) 按键或触摸事件在特定时间(5秒)内无响应。 小概率类型：BroadcastTimeout(10 seconds) BroadcastReceiver.onReceive()在特定时间(10秒)内无法处理完成。 小概率类型：ServiceTimeout(20 seconds) Service各个生命周期函数在特定的时间(20秒)内无法处理完成。 导致ANR的原因UI线程阻塞 耗时的网络访问 大量的数据读写 数据库操作 硬件操作（比如camera) 调用thread的join()方法、sleep()方法、wait()方法或者等待线程锁的时候 service binder的数量达到上限 system server中发生WatchDog ANR Service各个生命周期方法内进行和耗时操作，在20s内未处理完毕 其他线程持有锁，导致主线程等待超时 其它线程终止或崩溃导致主线程一直等待 BroadcastReceiver内进行了耗时操作，超过了10s的限制时间 CPU满负荷工作时进行I/O操作 当CPU使用率达到100%，在应用内仍在主线程上进行频繁的读写操作时，就会导致ANR的产生。 内存不够用 系统分配给每个App的可用内存是有限的，如果App内存在内存泄漏等情况的话，这个是会导致ANR的出现的。 只有主线程才会出现ANR 如何预防ANR其实说来说去，导致ANR发生的罪魁祸首就是在主线程中进行了耗时操作，那么在常规情况下，我们可以通过以下几种方式来防止ANR的产生： 主线程（UI线程）做耗时操作引发ANR预防 不在主线程（UI）线程中做耗时操作，开辟单独的子线程来处理耗时阻塞事务 不在Service、BroadcastReceiver内做耗时操作 不乱用Thread的join()、sleep()、wait()方法 CPU满负荷工作时进行I/O操作情况下预防 这种情况一般还是I/O操作在主线程上进行导致的，同理可以通过开启子线程的方式解决。 内存不足产生的ANR排查内存泄漏解决内存不够用的情况，推荐使用LeakCanary。 ANR排查当发生ANR后，系统会在data/anr/目录下生成一个名为traces.txt的文件，文件内主要记录了ANR产生时系统信息的一些情况。通过分析此文件可以找出问题出现的位置、原因。 参考：【Android】应用ANR分析 缓存三级缓存原理当 Android 端需要获得数据时比如获取网络中的图片，首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取 StringString,StringBuffer,StringBuilder区别 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况(线程安全) FragmentFragment与Fragment、Activity通信的四种方式 直接在一个Fragment中调用另一个Fragment的公开方法 通过接口调用 通过广播调用 直接调用Activity的公共方法 广播有序广播和无序广播 有序广播发送有序广播后，所有的接受者都可以接受，不可被拦截，不可被修改。 无序广播发送无序广播，会根据优先级，一级一级向下传递，接受者可以修改广播内容，也可以终止广播事件。 Android广播的注册方式和区别 静态注册静态注册可以成为常驻型广播，需要在Androidmanifest.xml文件中进行注册。这种注册方式不受页面生命周期的影响，即使退出页面，也可以接收到广播。此种注册为常驻型广播，会占用CPU资源。 动态注册动态注册就是需要在代码中注册，这种注册方式也叫非常驻型广播，受生命周期影响，退出后就无法接受广播。这种注册方式需要解绑，否则会导致内存泄漏。 引用类型 Android中的对象有着4种引用类型，垃圾回收器对于不同的引用类型有着不同的处理方式，了解这些处理方式有助于我们避免写出会导致内存泄露的代码。 StrongReference（强引用）强引用我们最常用的一种引用类型。当我们使用new关键字去新建一个对象的时候，创建的就是强引用。当一个对象具有强引用，那么垃圾回收器是绝对不会的回收和销毁它的。对象的强引用可以在程序中到处传递。很多情况下，会同时有多个引用指向同一个对象。 WeakReference（弱引用）弱引用通过类WeakReference来表示。弱引用并不能阻止垃圾回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。弱引用则没有这个问题。在垃圾回收器运行的时候，如果对一个对象的所有引用都是弱引用的话，该对象会被回收。 SoftReference（软引用）我们可以把软引用理解成一种稍强的弱引用,使用类SoftReference来表示。与弱引用的区别在于：如果一个对象只具有软引用，若内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，才会回收这些对象的内存。 所以从引用的强度来讲： 强引用 &gt; 软引用 &gt; 弱引用。 PhantomReference（虚引用）一个只被虚引用持有的对象可能会在任何时候被GC回收。虚引用对对象的生存周期完全没有影响，也无法通过虚引用来获取对象实例，仅仅能在对象被回收时，得到一个系统通知（只能通过是否被加入到ReferenceQueue来判断是否被GC，这也是唯一判断对象是否被GC的途径）,所以虚引用主要用来跟踪对象被垃圾回收的活动。 这里参考了一篇博客，博主总结的很好：理解Android中的引用类型 引用 2.2019Android高级面试题总结]]></content>
      <tags>
        <tag>面试</tag>
        <tag>Android</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用笔记]]></title>
    <url>%2F2019%2F01%2F21%2FGit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录Git使用过程中的一些操作指令 标签 创建标签git tag &lt;Tag Name&gt; 默认在最后的提交上打Taggit tag &lt;Tag Name&gt; &lt;SHA-1 Code&gt; 指定在某一笔提交上打Tag 创建带注释的Taggit tag -a &lt;Tag Name&gt; -m &lt;Tag Message&gt; &lt;SHA-1 Code&gt; 查看Taggit tag 查看Tag详细信息git show &lt;Tag Name&gt; 推送Tag到远程git push origin &lt;Tag Name&gt; 推送本地的所有Taggit push origin --tags 删除本地标签git tag -d &lt;Tag Name&gt; 删除远程标签先删除本地标签，然后推送到远程git push origin :refs/tags/&lt;Tag Name&gt; 分支 查看所有分支git branch -a 删除远程分支git push origin --delete BranchName 删除本地分支git branch -d BranchName 本地仓库关联到远程仓库 首先拿到远程仓库的地址 以GitHub为例：`git@github.com:[username]/[repository name]` 将本地代码转换为Git仓库 git init 将本地仓库关联到远程仓库 git remote add origin [remote address] 同步远程仓库,和远程分支关联 git pull origin master 提交代码 git add 和 git commit 推送到远程仓库 git push origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native中使用自定义IconFont]]></title>
    <url>%2F2018%2F12%2F15%2FReact-Native%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89IconFont%2F</url>
    <content type="text"><![CDATA[初学React Native，在App中有一个TabBar需要用到图标。平时在开发Android时TabBar图标基本不用图片，都是使用字体图标替代图片，字体图标有自适应屏幕的特性，不会再不同分辨率上失真，从而免去了适配不同分辨率手机的困扰。所以在想React Native中是否可以使用字体图标，研究了一下，果然可行，记录如下。 用到的工具类库和资源： react-native-vector-icons 阿里巴巴字体图标库 最终效果先展示一下使用效果：1234567//导入组件import Icon from './js/common/IconFont';//使用组件&lt;Icon name='icon_hot' size=&#123;20&#125; color='lightgreen' /&gt;&lt;Icon name='icon_trending' size=&#123;20&#125; color='lightgreen' /&gt;&lt;Icon name='icon_collect' size=&#123;20&#125; color='lightgreen' /&gt;&lt;Icon name='icon_user' size=&#123;20&#125; color='lightgreen' /&gt; 效果如图： 安装 首先安装第三方的字体库组件,这里推荐使用 react-native-vector-icons ,安装步骤如下： 安装依赖：npm install react-native-vector-icons --save (可选)如果需要使用默认的字体文件，则需要链接资源库 自动：react-native link 手动(不推荐)：GitHub官方仓库Installation部分 这里需要重新编译运行项目。 使用测试是否安装成功： 1234//导入import Icon from 'react-native-vector-icons/FontAwesome';//使用组件&lt;Icon name="rocket" size=&#123;30&#125; color="#900" /&gt; 使用自定义的字体文件 从阿里巴巴字体图标库下载需要的字体图标，添加到自己创建的项目中。 点击下载，打包下载到本地： 解压文件，iconfont.ttf文件就是后面需要用到的文件： 将文件放到指定的位置： Android:在Android项目的assets目录下创建文件夹，名为fonts，将上面解压出来的ttf文件拷贝到此目录下。 IOS：为了便于字体的统一管理，在项目目录下创建fonts文件夹，并将下载的字体文件拖到文件夹中，Xcode会弹出下图提示框，Add to target 选择当前项目： 确保添加文件后，项目的Build Phases的Copy Bundle Resources中有刚刚添加的字体文件，如下图：接着再修改info.plist文件，在Information Property List下的Fonts provided by application下添加一个item,value就是字体文件的名字，如下图：至此，ios配置完成. 使用自定义的字体文件，如何使用先看看源码： 12345678910/*** FontAwesome icon set component.* Usage: &lt;FontAwesome name="icon-name" size=&#123;20&#125; color="#4F8EF7" /&gt;*/import createIconSet from './lib/create-icon-set';import glyphMap from './glyphmaps/FontAwesome.json';const iconSet = createIconSet(glyphMap, 'FontAwesome', 'FontAwesome.ttf');export default iconSet; FontAwesome.json文件内容如下： 1234567&#123; "glass": 61440, "music": 61441, "search": 61442, "envelope-o": 61443, "heart": 61444,&#125; FontAwesome字体返回的是一个iconSet,简单理解为是一个显示字体图标的组件，创建这个组件需要三个参数，分别为： glyphMap: 是一个json对象，存储的是图标的信息，其中key是字体图标的名字，value是图标的十进制编码。 fontFamily: 字体库对应的fontFamily，可以在下载字体的网站查得到，以阿里巴巴图标库为例：创建的项目下有编辑项目，点开就可以看见图标库的fontFamily。 fontFile: 字体文件的名称 根据FontAwesome的创建方式，我们可以自己创建一个自定义的字体图标，目前已经可以拿到fontFamily和字体文件，还缺少包含字体名称和值的json对象。以阿里巴巴字体图标库为例，我们可以在项目图标下找到图标的十六进制的值，如下图：e663即为图标的16进制的值，我们需要将其转换为10进制的值，我用到字体图标不多，所以用在线转换工具就拿到了需要的10进制的值，如果图标比较多的话，可以写一段代码从下载下来的iconfont.css文件中截取再转换生成对应的json文件，还可以重复使用，有时间可以试试！ 创建自定义的图标组件，代码如下： 1234567891011121314//IconFont.jsimport createIconSet from 'react-native-vector-icons/lib/create-icon-set';const glyphMap = &#123; 'icon_user': 58979, 'icon_collect': 58928, 'icon_hot':59222, 'icon_trending':60788,&#125;//映射表，fontFamily，字体文件const IconFont = createIconSet(glyphMap, 'iconfont', 'iconfont.ttf');export default IconFont; 由于图标较少，我直接将字体键值放到了一个json对象，没有单独创建文件。 使用方式 1234//导入组件import Icon from './js/common/IconFont';//使用组件&lt;Icon name='icon_hot' size=&#123;20&#125; color='lightgreen' /&gt; 效果文章的开始已经展示过了，至此自定义字体库成功使用！]]></content>
      <tags>
        <tag>React Native</tag>
        <tag>IconFont</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android沉浸式状态栏]]></title>
    <url>%2F2018%2F11%2F23%2FAndroid%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[Android 5.0以上可以通过设置 colorPrimaryDark ，设置状态栏颜色，使之余App颜色一致来实现状态栏沉浸. Android 4.4可以设置状态栏透明，通过绘制一个和状态栏高度相同的View，添加到窗口顶层的View上面，在设置根布局的属性达到状态栏沉浸的目的。 Android 4.4一下无法实现状态栏沉浸。 下面的方法适用于Android4.4以上的状态沉浸，需要在setContentView()方法后调用 /** * 处理状态栏变色 * * @param color 状态栏颜色 * 4.4状态栏会显示为该颜色 * 5.0以上会显示半透明效果 */ public void translucentBar(int color){ if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.KITKAT){ //设置状态栏透明 getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); //获取状态栏高度 int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); int statusBarHeight = getResources().getDimensionPixelSize(resourceId); //绘制一个和状态栏高度一致的View View view=new View(this); LinearLayout.LayoutParams layoutParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,statusBarHeight); view.setLayoutParams(layoutParams); view.setBackgroundColor(ContextCompat.getColor(this,color)); //添加布局到布局中 ViewGroup viewGroup= (ViewGroup) getWindow().getDecorView(); viewGroup.addView(view); //设置根布局的参数 ViewGroup rootView= (ViewGroup) ((ViewGroup)this.findViewById(android.R.id.content)).getChildAt(0); rootView.setFitsSystemWindows(true); rootView.setClipToPadding(true); } }]]></content>
      <tags>
        <tag>状态栏</tag>
      </tags>
  </entry>
</search>
